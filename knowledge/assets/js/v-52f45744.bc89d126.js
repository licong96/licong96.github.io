"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[3308],{206:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-52f45744",path:"/web-developer/front-end/frame/vue.html",title:"vue",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"基础知识",slug:"基础知识",children:[]},{level:2,title:"原理",slug:"原理",children:[{level:3,title:"Vue2.0/3.0 双向数据绑定原理",slug:"vue2-0-3-0-双向数据绑定原理",children:[]}]},{level:2,title:"vue-router",slug:"vue-router",children:[]},{level:2,title:"vuex",slug:"vuex",children:[]},{level:2,title:"单元测试",slug:"单元测试",children:[]},{level:2,title:"服务器渲染",slug:"服务器渲染",children:[]},{level:2,title:"组件库",slug:"组件库",children:[]},{level:2,title:"关于 vue 的一些问题",slug:"关于-vue-的一些问题",children:[]},{level:2,title:"组件化",slug:"组件化",children:[]},{level:2,title:"如何理解 MVVM 模型？",slug:"如何理解-mvvm-模型",children:[]},{level:2,title:"Vue3.0 - Proxy",slug:"vue3-0-proxy",children:[]},{level:2,title:"Object.defineProperty 的缺点",slug:"object-defineproperty-的缺点",children:[]},{level:2,title:"Proxy 基本使用",slug:"proxy-基本使用",children:[]},{level:2,title:"虚拟 DOM(Virtual DOM)",slug:"虚拟-dom-virtual-dom",children:[]},{level:2,title:"用 JS 模拟 DOM 结构",slug:"用-js-模拟-dom-结构",children:[{level:3,title:"diff 算法",slug:"diff-算法",children:[]},{level:3,title:"key 的作用",slug:"key-的作用",children:[]}]},{level:2,title:"vue3",slug:"vue3",children:[]},{level:2,title:"搭建项目",slug:"搭建项目",children:[{level:3,title:"必备插件",slug:"必备插件",children:[]},{level:3,title:"目录结构",slug:"目录结构",children:[]}]},{level:2,title:"响应性 API",slug:"响应性-api",children:[{level:3,title:"用法",slug:"用法",children:[]}]},{level:2,title:"组合式 API",slug:"组合式-api",children:[]},{level:2,title:"teleport",slug:"teleport",children:[]},{level:2,title:"v-model",slug:"v-model",children:[]},{level:2,title:"小技巧",slug:"小技巧",children:[{level:3,title:"列表渲染",slug:"列表渲染",children:[]},{level:3,title:"key",slug:"key",children:[]},{level:3,title:"ref",slug:"ref",children:[]}]},{level:2,title:"Provide / Inject",slug:"provide-inject",children:[]},{level:2,title:"Proxy",slug:"proxy",children:[]},{level:2,title:"Vue Class Component",slug:"vue-class-component",children:[]},{level:2,title:"使用技巧",slug:"使用技巧",children:[]}],filePathRelative:"web-developer/front-end/frame/vue.md",git:{updatedTime:1674894334e3,contributors:[{name:"黎聪",email:"licong23@xdf.cn",commits:2},{name:"licong96",email:"licong19961204@gmail.com",commits:1}]}}},1323:(n,e,a)=>{a.r(e),a.d(e,{default:()=>u});var s=a(6252);const t=(0,s.uE)('<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> vue</h1><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h2><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><h3 id="vue2-0-3-0-双向数据绑定原理" tabindex="-1"><a class="header-anchor" href="#vue2-0-3-0-双向数据绑定原理" aria-hidden="true">#</a> Vue2.0/3.0 双向数据绑定原理</h3><p>各自的好处，到掘金上面寻找一些文章。</p><h4 id="vue2-0-使用-es5-方法-defineproperty" tabindex="-1"><a class="header-anchor" href="#vue2-0-使用-es5-方法-defineproperty" aria-hidden="true">#</a> Vue2.0 使用 ES5 方法：defineProperty</h4><p>数据劫持</p><p>Object.defineProperty(obj, &#39;key&#39;, { get() {}, set() {}, });</p><h4 id="vue3-0-使用-es6-方法-proxy" tabindex="-1"><a class="header-anchor" href="#vue3-0-使用-es6-方法-proxy" aria-hidden="true">#</a> Vue3.0 使用 ES6 方法：Proxy</h4><p>let obj = {};</p><p>obj = new Proxy(obj, { get(target, prop) {}, set(target, prop, value) {} });</p><h2 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h2><h2 id="vuex" tabindex="-1"><a class="header-anchor" href="#vuex" aria-hidden="true">#</a> vuex</h2><h2 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试" aria-hidden="true">#</a> 单元测试</h2><h2 id="服务器渲染" tabindex="-1"><a class="header-anchor" href="#服务器渲染" aria-hidden="true">#</a> 服务器渲染</h2><h2 id="组件库" tabindex="-1"><a class="header-anchor" href="#组件库" aria-hidden="true">#</a> 组件库</h2><ol><li>vdom</li><li>模板渲染</li></ol><p>组件化 响应式 vdom 和 diff 模板编译 渲染过程 前端路由</p><p>重点：整体流程是否全面，热门技术是否有深度。</p><h2 id="关于-vue-的一些问题" tabindex="-1"><a class="header-anchor" href="#关于-vue-的一些问题" aria-hidden="true">#</a> 关于 vue 的一些问题</h2><ol><li>v-for 为什么要使用 key？ 答：diff 算法通过 tag 和 key，来判断是否是相同的 node。目的是为了减少渲染次数，提高渲染性能。</li></ol><h2 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h2><p>引入一个组件，传入相关信息。</p><h2 id="如何理解-mvvm-模型" tabindex="-1"><a class="header-anchor" href="#如何理解-mvvm-模型" aria-hidden="true">#</a> 如何理解 MVVM 模型？</h2><p>数据驱动视图。 只需要修改数据，框架就会根据数据的变化更新视图。</p><p>M = Modul V = View VM = ViewModul</p><p>View &lt;=&gt; ViewModul &lt;=&gt; Modul</p><h2 id="vue3-0-proxy" tabindex="-1"><a class="header-anchor" href="#vue3-0-proxy" aria-hidden="true">#</a> Vue3.0 - Proxy</h2><p>3.0：使用 Proxy 实现数据响应式。</p><p>2.0：使用 defineProperty 实现数据响应式。</p><h2 id="object-defineproperty-的缺点" tabindex="-1"><a class="header-anchor" href="#object-defineproperty-的缺点" aria-hidden="true">#</a> Object.defineProperty 的缺点</h2><ol><li>深度监听需要一次性递归，有性能瓶颈。</li><li>无法监听新增属性和删除属性，需要使用 Vue.set 等方法。</li><li>无法原生监听数组，需要特殊处理。</li></ol><h2 id="proxy-基本使用" tabindex="-1"><a class="header-anchor" href="#proxy-基本使用" aria-hidden="true">#</a> Proxy 基本使用</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>new Proxy(data, {\n    get(target, key, receiver) {\n        const result = Reflect.get(target, key, receiver);\n        return result;\n    },\n    set(target, key, val, receiver) {\n        const result = Reflect.set(target, key, val, receiver);\n        return result;\n    },\n    deleteProperty(target, key) {\n        const result = Reflect.deleteProperty(target, key);\n        return result;\n    }\n})\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="虚拟-dom-virtual-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-virtual-dom" aria-hidden="true">#</a> 虚拟 DOM(Virtual DOM)</h2><p>问：什么是 vdom？ 答：vdom 是真实 DOM 的一种映射。使用 JS 模拟出来的一种 DOM 结构。</p><p>问：vdom 有什么用？ 目的是为了提高性能。DOM 操作本身非常耗费性能，JS 本身运行却很快，为了减少复杂度，减少性能消耗，所以使用 JS 模拟 DOM 结构，先计算出最小变更，再操作 DOM。</p><h2 id="用-js-模拟-dom-结构" tabindex="-1"><a class="header-anchor" href="#用-js-模拟-dom-结构" aria-hidden="true">#</a> 用 JS 模拟 DOM 结构</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;root&quot;&gt;\n    &lt;h1 class=&quot;title&quot;&gt;title name&lt;/h1&gt;\n    &lt;ul class=&quot;list&quot;&gt;\n        &lt;li class=&quot;list-item&quot;&gt;item&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const vdom = {\n    tag: &#39;div&#39;,\n    props: {\n        id: &#39;root&#39;\n    },\n    children: [\n        {\n            tag: &#39;h1&#39;,\n            props: {\n                className: &#39;title&#39;,\n            },\n            children: &#39;title name&#39;\n        },\n        {\n            tag: &#39;ul&#39;,\n            props: {\n                className: &#39;list&#39;\n            },\n            children: [\n                {\n                    tag: &#39;li&#39;,\n                    props: {\n                        className: &#39;list-item&#39;\n                    },\n                    children: &#39;item&#39;\n                }\n            ]\n        }\n    ]\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h3 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法" aria-hidden="true">#</a> diff 算法</h3><p>问：什么是 diff 算法？ 答：diff 算法是 JS 对虚拟 DOM 对比的过程。</p><p>问：diff 算法有什么用？ 答：通过这个算法，计算对比出 vdom 的最小变更。</p><p>问：diff 的比较规则是什么？ 答： 1.只比较同一级别，不跨级比较。 2.同一级中 tag 不相同，则直接删除重建，不深度比较。 3.同一级中 tag 和 key，两者都相同，则认为是相同节点，不深度比较。</p><h3 id="key-的作用" tabindex="-1"><a class="header-anchor" href="#key-的作用" aria-hidden="true">#</a> key 的作用</h3><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> vue3</h2><h2 id="搭建项目" tabindex="-1"><a class="header-anchor" href="#搭建项目" aria-hidden="true">#</a> 搭建项目</h2><h3 id="必备插件" tabindex="-1"><a class="header-anchor" href="#必备插件" aria-hidden="true">#</a> 必备插件</h3><ul><li>Vue3 + script setup + ts + Vite + Volar</li><li>CSS 预处理器: sass</li><li>PostCSS: autoprefixer、postcss-pxtorem</li><li>amfe-flexible</li></ul><h3 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h3><h2 id="响应性-api" tabindex="-1"><a class="header-anchor" href="#响应性-api" aria-hidden="true">#</a> 响应性 API</h2>',51),l={href:"https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive",target:"_blank",rel:"noopener noreferrer"},p=(0,s.Uk)("响应性基础 API"),r=(0,s.uE)('<ul><li>reactive</li><li>ref</li><li>toRef</li><li>toRefs</li><li>shallowRef</li></ul><p><strong>reactive</strong></p><p>返回对象的响应式副本。将解包所有深层的 <code>refs</code>，同时维持 <code>ref</code> 的响应性。</p><p><strong>ref</strong></p><p>接受一个内部值并返回一个响应式且可变的 <code>ref</code> 对象，里面仅有一个 <code>.value</code> property，指向该内部值。</p><p><strong>toRef</strong></p><p>可以用来为源响应式对象上的某个 property 新创建一个 <code>ref</code>。然后，<code>ref</code> 可以被传递，它会保持对其源 property 的响应式连接。 当你要将 <code>prop</code> 的 <code>ref</code> 传递给复合函数时，<code>toRef</code> 很有用。</p><p><strong>toRefs</strong></p><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <code>ref</code>。</p><p><strong>shallowRef</strong></p><p>创建一个跟踪自身 <code>.value</code> 变化的 ref 但不会使其值也变成响应式的。</p><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法" aria-hidden="true">#</a> 用法</h3><p><code>ref</code>通常用来处理简单的基本类型数据，返回一个响应式 Ref 对象。<code>reactive</code>用来定义更加复杂的数据类型，但是定义后里面的变量取出来就不再是响应式 Ref 对象，所以需要使用<code>toRefs</code>转化为响应式 Ref 对象。</p><p>如果只修改引用类型的一个属性，推荐用<code>reactive</code>；如果需要给变量重新赋值，推荐使用<code>ref</code>。</p><ul><li><code>toRef</code> 将传入的 <code>props</code> 其中一个属性转成响应式</li><li><code>toRefs</code> 将传入的 <code>props</code> 所有属性转成响应式</li></ul><h2 id="组合式-api" tabindex="-1"><a class="header-anchor" href="#组合式-api" aria-hidden="true">#</a> 组合式 API</h2><ul><li>setup</li><li>生命周期钩子</li><li>Provide / Inject</li></ul><p>把同一功能的代码放到一起维护，也可以抽离到一个组建中。</p><h2 id="teleport" tabindex="-1"><a class="header-anchor" href="#teleport" aria-hidden="true">#</a> teleport</h2><h2 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h2><h2 id="小技巧" tabindex="-1"><a class="header-anchor" href="#小技巧" aria-hidden="true">#</a> 小技巧</h2><h3 id="列表渲染" tabindex="-1"><a class="header-anchor" href="#列表渲染" aria-hidden="true">#</a> 列表渲染</h3><p>你可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item of items<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>还可以用第三个参数作为索引：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(value, name, index) in myObject<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n  {{ index }}. {{ name }}: {{ value }}\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="key" tabindex="-1"><a class="header-anchor" href="#key" aria-hidden="true">#</a> key</h3><p>使用 key 强制替换元素或组件，而不是重复使用它，达到一些特别的目的。</p><p>比如：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡。</p><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h3><p><code>ref</code> 为我们的值创建了一个响应式引用。在整个组合式 API 中会经常使用引用的概念。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment">// { value: 0 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n\ncounter<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="provide-inject" tabindex="-1"><a class="header-anchor" href="#provide-inject" aria-hidden="true">#</a> Provide / Inject</h2><h2 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h2><h2 id="vue-class-component" tabindex="-1"><a class="header-anchor" href="#vue-class-component" aria-hidden="true">#</a> Vue Class Component</h2>',38),i={href:"https://class-component.vuejs.org/",target:"_blank",rel:"noopener noreferrer"},c=(0,s.Uk)("Vue Class Component"),o=(0,s.uE)('<h2 id="使用技巧" tabindex="-1"><a class="header-anchor" href="#使用技巧" aria-hidden="true">#</a> 使用技巧</h2><h4 id="definecomponent" tabindex="-1"><a class="header-anchor" href="#definecomponent" aria-hidden="true">#</a> defineComponent</h4><p>可以创建一个自定义组件。</p><p>可以创建一个只有在需要时才会加载的异步组件。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;defineComponent&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="setup-中使用-emit" tabindex="-1"><a class="header-anchor" href="#setup-中使用-emit" aria-hidden="true">#</a> setup 中使用 emit</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    context<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&#39;change&#39;</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',7),u={render:function(n,e){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.j4)(s.HY,null,[t,(0,s.Wm)("p",null,[(0,s.Wm)("a",l,[p,(0,s.Wm)(a)])]),r,(0,s.Wm)("p",null,[(0,s.Wm)("a",i,[c,(0,s.Wm)(a)])]),o],64)}}}}]);