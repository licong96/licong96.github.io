"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[9194],{180:(e,a,t)=>{t.r(a),t.d(a,{data:()=>i});const i={key:"v-92dbdaaa",path:"/web-developer/front-end/frame/react.html",title:"react",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"react-router-dom",slug:"react-router-dom",children:[]},{level:2,title:"redux",slug:"redux",children:[]},{level:2,title:"基本概念",slug:"基本概念",children:[]},{level:2,title:"单项数据流",slug:"单项数据流",children:[]},{level:2,title:"dav",slug:"dav",children:[]},{level:2,title:"组件框架",slug:"组件框架",children:[]},{level:2,title:"SSR服务器渲染 next.js",slug:"ssr服务器渲染-next-js",children:[]},{level:2,title:"setState",slug:"setstate",children:[]},{level:2,title:"不可变值",slug:"不可变值",children:[]},{level:2,title:"可能是异步更新",slug:"可能是异步更新",children:[]},{level:2,title:"可能会被合并",slug:"可能会被合并",children:[]},{level:2,title:"batchUpdata 机制",slug:"batchupdata-机制",children:[]},{level:2,title:"事务机制",slug:"事务机制",children:[]}],filePathRelative:"web-developer/front-end/frame/react.md",git:{updatedTime:1646300916e3,contributors:[{name:"黎聪",email:"licong23@xdf.cn",commits:1}]}}},1314:(e,a,t)=>{t.r(a),t.d(a,{default:()=>r});const i=(0,t(6252).uE)('<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> react</h1><ul><li>JSX语法</li><li>状态</li><li>属性</li><li>ref</li><li>组件</li><li>生命周期</li><li>Hooks</li></ul><h2 id="react-router-dom" tabindex="-1"><a class="header-anchor" href="#react-router-dom" aria-hidden="true">#</a> react-router-dom</h2><h2 id="redux" tabindex="-1"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> redux</h2><ul><li>redux</li><li>react-redux</li><li>中间件</li></ul><ol><li>基本概念</li><li>单项数据流</li><li>react-redux</li><li>异步 action</li><li>中间件</li></ol><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><p>不可变值 纯函数</p><p>store state action reducer</p><h2 id="单项数据流" tabindex="-1"><a class="header-anchor" href="#单项数据流" aria-hidden="true">#</a> 单项数据流</h2><p>首先是 dispatch(action)，然后是 reducer 产生一个新的 newState，subscribe 出发通知。</p><h2 id="dav" tabindex="-1"><a class="header-anchor" href="#dav" aria-hidden="true">#</a> dav</h2><h2 id="组件框架" tabindex="-1"><a class="header-anchor" href="#组件框架" aria-hidden="true">#</a> 组件框架</h2><ul><li>umi</li></ul><h2 id="ssr服务器渲染-next-js" tabindex="-1"><a class="header-anchor" href="#ssr服务器渲染-next-js" aria-hidden="true">#</a> SSR服务器渲染 next.js</h2><h2 id="setstate" tabindex="-1"><a class="header-anchor" href="#setstate" aria-hidden="true">#</a> setState</h2><ol><li>不可变值</li><li>可能是异步更新</li><li>可能会被合并</li></ol><h2 id="不可变值" tabindex="-1"><a class="header-anchor" href="#不可变值" aria-hidden="true">#</a> 不可变值</h2><p>不要直接修改 state，要使用一个全新的值。</p><h2 id="可能是异步更新" tabindex="-1"><a class="header-anchor" href="#可能是异步更新" aria-hidden="true">#</a> 可能是异步更新</h2><p>问：什么时候是异步？ 答：刚设置完 state，立马获取值，拿不到最新的值，这是异步的。想要拿到最新值，需要使用第二个参数。</p><p>问：什么时候是同步？ 答：在定时器中使用是同步。还有自定义的DOM事件也是同步的。</p><p>总结：如果是由React引发的事件处理，调用setState会异步更新this.state，除此之外的setState调用会同步执行this.state 。</p><h2 id="可能会被合并" tabindex="-1"><a class="header-anchor" href="#可能会被合并" aria-hidden="true">#</a> 可能会被合并</h2><p>问：什么时候会合并？ 答：异步更新，传入对象，更新前会被合并，只执行一次。类使用Object.assign。</p><p>问：什么时候不会合并？ 答：setState 传入函数，不会被合并。</p><h2 id="batchupdata-机制" tabindex="-1"><a class="header-anchor" href="#batchupdata-机制" aria-hidden="true">#</a> batchUpdata 机制</h2><p>如果命中batchUpdata机制，会使用异步更新，否者同步更新。</p><p>isBatchingUdate 默认是true，处于机制中。</p><p>setState 本身无所谓同步还是异步，取决于能否命中 batchUpdata 机制，依据是判断 isBatchingUdate。</p><p>问：能命中机制的有哪些？ 答：生命周期，React中注册的事件，所有React能管理的入口。</p><p>不能命中的有：定时器，自定义的DOM事件，React不能管理的入口。</p><h2 id="事务机制" tabindex="-1"><a class="header-anchor" href="#事务机制" aria-hidden="true">#</a> 事务机制</h2><p>先定义一个开始逻辑，然后执行其它任务操作，再执行一个结束逻辑。</p>',34),r={render:function(e,a){return i}}}}]);