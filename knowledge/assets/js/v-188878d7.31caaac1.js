"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[2685],{2296:(e,i,l)=>{l.r(i),l.d(i,{data:()=>a});const a={key:"v-188878d7",path:"/web-developer/front-end/architect/section-3.html",title:"阶段三：服务端",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"14 周，服务端技术选型",slug:"_14-周-服务端技术选型",children:[{level:3,title:"框架对比",slug:"框架对比",children:[]},{level:3,title:"数据库",slug:"数据库",children:[]},{level:3,title:"登录校验",slug:"登录校验",children:[]},{level:3,title:"JWT 和 Session 的重要区别",slug:"jwt-和-session-的重要区别",children:[]},{level:3,title:"SSO 和 OAuth2",slug:"sso-和-oauth2",children:[]},{level:3,title:"单元测试",slug:"单元测试",children:[]},{level:3,title:"supertest 接口测试",slug:"supertest-接口测试",children:[]},{level:3,title:"PM2 + Nginx",slug:"pm2-nginx",children:[]},{level:3,title:"开发环境效率工具",slug:"开发环境效率工具",children:[]}]},{level:2,title:"15 周，CI/CD 自动化",slug:"_15-周-ci-cd-自动化",children:[{level:3,title:"使用 GitHub actions",slug:"使用-github-actions",children:[]},{level:3,title:"使用 Docker",slug:"使用-docker",children:[]},{level:3,title:"自动发布到测试机",slug:"自动发布到测试机",children:[]}]},{level:2,title:"第 16 周 编辑器服务端基础 API 开发",slug:"第-16-周-编辑器服务端基础-api-开发",children:[{level:3,title:"技术方案设计和基础功能开发",slug:"技术方案设计和基础功能开发",children:[]},{level:3,title:"1.服务端技术方案设计的方法",slug:"_1-服务端技术方案设计的方法",children:[]},{level:3,title:"1.1 接口设计",slug:"_1-1-接口设计",children:[]},{level:3,title:"1.2 数据库设计",slug:"_1-2-数据库设计",children:[]},{level:3,title:"B 端-server 整体架构图",slug:"b-端-server-整体架构图",children:[]},{level:3,title:"biz-editor-server 端技术方案",slug:"biz-editor-server-端技术方案",children:[]},{level:3,title:"基本功能开发",slug:"基本功能开发",children:[]}]}],filePathRelative:"web-developer/front-end/architect/section-3.md",git:{updatedTime:1683600236e3,contributors:[{name:"licong96",email:"licong19961204@gmail.com",commits:4}]}}},7889:(e,i,l)=>{l.r(i),l.d(i,{default:()=>n});const a=(0,l(6252).uE)('<h1 id="阶段三-服务端" tabindex="-1"><a class="header-anchor" href="#阶段三-服务端" aria-hidden="true">#</a> 阶段三：服务端</h1><h2 id="_14-周-服务端技术选型" tabindex="-1"><a class="header-anchor" href="#_14-周-服务端技术选型" aria-hidden="true">#</a> 14 周，服务端技术选型</h2><ul><li><p>node.js 框架选型：Koa2</p></li><li><p>数据库：Mysql、MongoDB、Redis</p></li><li><p>登录校验：JWT</p></li><li><p>单元测试和接口测试：Jest</p></li><li><p>上线服务：PM2 + nginx</p></li><li><p>开发环境效率工具</p></li></ul><h3 id="框架对比" tabindex="-1"><a class="header-anchor" href="#框架对比" aria-hidden="true">#</a> 框架对比</h3><p>Koa2 更加简单，精简</p><h3 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库" aria-hidden="true">#</a> 数据库</h3><ul><li>Mysql 和 Sequelize</li><li>Mongodb 和 Mongoose</li><li>Redis</li></ul><p>Mysql 适合存储表格形式，格式规整的数据。MongoDB 用于存储文件，格式零散的数据。</p><h4 id="数据结构设计" tabindex="-1"><a class="header-anchor" href="#数据结构设计" aria-hidden="true">#</a> 数据结构设计</h4><ul><li>JSON 数据存储作品内容，使用 MongoDB</li><li>用户信息，作品其它信息，表格形式存储，使用 MySQL</li><li>缓存能力，使用 Redis</li></ul><h3 id="登录校验" tabindex="-1"><a class="header-anchor" href="#登录校验" aria-hidden="true">#</a> 登录校验</h3><p>web 常用的登录鉴权方式：</p><ul><li>JWT</li><li>Cookie 和 Session</li><li>SSO 和 OAuth2</li></ul><h4 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt" aria-hidden="true">#</a> JWT</h4><ul><li>JSON Web Token</li></ul><p>校验过程：</p><ol><li>客户端输入用户名和密码，传给服务端</li><li>服务端验证成功，返回一段将用户信息加密后的 token 字符串给客户端</li><li>客户端获得 token 之后，自己存储下来</li><li>接下来客户端所有接口请求，都在<code>header</code>中带上这段 token 作为 Authorization 字段</li><li>服务端接收到请求后，拿到 token 会解密，判断</li></ol><p>优点：</p><ul><li>无需在服务端存储用户信息：服务端不需要在存储用户信息，因为 JWT 中已经包含了所有必要的信息。</li><li>成本低、维护简单</li><li>不占用服务器内存</li><li>多进程、多服务器，不受影响</li><li>不受跨域限制</li></ul><p>缺点：</p><ul><li>无法主动退出：JWT 令牌一旦生成，其有效期内就可以一直使用，无法主动退出。</li><li>载荷大小有限制：由于 JWT 令牌需要进行传输和存储，其载荷大小有限制，不适用于存储大量数据的场景。</li><li>无法快速封禁某个登录的用户（极少有这种需求情况）</li></ul><h4 id="cookie-和-session" tabindex="-1"><a class="header-anchor" href="#cookie-和-session" aria-hidden="true">#</a> Cookie 和 Session</h4><p>Cookie 校验过程：</p><ol><li>客户端输入用户名和密码，传给服务端</li><li>服务端验证成功，会生成一个<code>Session ID</code>存储在服务端，并在响应头中添加<code>Set-Cookie</code>同时返回给浏览器</li><li>接下来客户端所有接口请求，都自动带上<code>cookie</code>（浏览器的默认行为，Http 协议的规定）</li><li>服务端通过解析 Cookie 中的<code>Session ID</code>，与服务器端存储的 Session 进行对比判断</li></ol><p>Session：具体的用户信息存储在 session 中，可以理解为是一个 JSON 数据，放在服务端。cookie 只存储 userid。</p><p>优点：用户信息存储在服务端，可以快速封禁某个登录的用户，可以选择 Session</p><p>缺点：</p><ul><li>占用服务端内存，有硬件成本。</li><li>多进程，多服务器时，不好同步，需要将 Session 放到第三方缓存服务中</li><li>跨域传递 cookie 时需要特殊配置</li></ul><h3 id="jwt-和-session-的重要区别" tabindex="-1"><a class="header-anchor" href="#jwt-和-session-的重要区别" aria-hidden="true">#</a> JWT 和 Session 的重要区别</h3><ul><li>JWT 用户信息存储在客户端</li><li>Session 用户信息存储在服务端</li></ul><h3 id="sso-和-oauth2" tabindex="-1"><a class="header-anchor" href="#sso-和-oauth2" aria-hidden="true">#</a> SSO 和 OAuth2</h3><ul><li>SSO 企业集团统一登录，然后可以访问集团下面所有系统</li><li>OAuth2 第三方鉴权登录，比如微信授权登录</li></ul><h4 id="短信验证码登录" tabindex="-1"><a class="header-anchor" href="#短信验证码登录" aria-hidden="true">#</a> 短信验证码登录</h4><p>短信验证码是一种登录的方式，无需注册，无需记住密码。但是要花钱，还要防止攻击，恶意刷短信接口</p><h3 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试" aria-hidden="true">#</a> 单元测试</h3><p>抽离单元，主要用来测试逻辑</p><h4 id="单元测试为何难以落实" tabindex="-1"><a class="header-anchor" href="#单元测试为何难以落实" aria-hidden="true">#</a> 单元测试为何难以落实？</h4><p>因为混淆了单元测试和集成测试，导致单元测试代码中有 Mock。需要服务器启动才能执行的代码，就不再是单元测试，而是集成测试。</p><ol><li><p>单元测试是针对一个单元，即单一的功能。</p></li><li><p>单元测试是针对一段逻辑（比如判断和循环），平铺直叙的代码不用测试。</p></li></ol><p>测试覆盖率，应该看抽离出来的单元模块，而非所有代码。有些代码不适合或不需要单元测试。</p><p>还有一个原因是研发流程不规范。</p><h3 id="supertest-接口测试" tabindex="-1"><a class="header-anchor" href="#supertest-接口测试" aria-hidden="true">#</a> supertest 接口测试</h3><p>保证安全感。</p><p>jest + supertest</p><p>单元测试和接口测试的概念需要区分开，不要彼此依赖。</p><h3 id="pm2-nginx" tabindex="-1"><a class="header-anchor" href="#pm2-nginx" aria-hidden="true">#</a> PM2 + Nginx</h3><p>线上服务关键：稳定 + 高效</p><p>PM2 服务只对内开启，nginx 服务作为内部和外部的代理</p><p>客户端接口统一先访问 Nginx 服务</p><h4 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h4><ul><li>日志记录</li><li>日志拆分：PM2 日志拆分，nginx 日志拆分，框架日志拆分</li></ul><h3 id="开发环境效率工具" tabindex="-1"><a class="header-anchor" href="#开发环境效率工具" aria-hidden="true">#</a> 开发环境效率工具</h3><ul><li>eslint prettier</li><li>pre-commit</li><li>commit 规范</li></ul><h2 id="_15-周-ci-cd-自动化" tabindex="-1"><a class="header-anchor" href="#_15-周-ci-cd-自动化" aria-hidden="true">#</a> 15 周，CI/CD 自动化</h2><ul><li>使用 GitHub actions</li><li>使用 Docker</li><li>使用 Docker-compose</li><li>自动发布到测试机</li></ul><h3 id="使用-github-actions" tabindex="-1"><a class="header-anchor" href="#使用-github-actions" aria-hidden="true">#</a> 使用 GitHub actions</h3><p>用途：</p><ul><li>master 分支，自动化测试</li><li>dev 分支，自动部署到测试服务</li><li>提交 tag，自动上线，支持回滚</li></ul><h4 id="关于测试流程" tabindex="-1"><a class="header-anchor" href="#关于测试流程" aria-hidden="true">#</a> 关于测试流程</h4><ul><li><p>pre-commit 时执行本地接口测试<code>npm run test:local</code></p></li><li><p>master push 时执行远程接口测试<code>npm run test:remote</code></p></li></ul><h3 id="使用-docker" tabindex="-1"><a class="header-anchor" href="#使用-docker" aria-hidden="true">#</a> 使用 Docker</h3><p>使用 Docker 构建 node.js 项目</p><p>通过<code>Docker-compose</code>搭建开发环境</p><h3 id="自动发布到测试机" tabindex="-1"><a class="header-anchor" href="#自动发布到测试机" aria-hidden="true">#</a> 自动发布到测试机</h3><p>dev 分支 push 时，自动部署到测试机</p><ul><li>github actions 监听 git 提交，并执行自定义命令</li><li>docker 一键部署开发环境</li></ul><h4 id="配置测试服务器" tabindex="-1"><a class="header-anchor" href="#配置测试服务器" aria-hidden="true">#</a> 配置测试服务器</h4><ul><li><p>创建 work 账号</p></li><li><p>用 root 登录，创建 work 账号</p></li><li><p>添加 work 的 sudo 权限</p></li><li><p>添加登录信任</p></li><li><p>安装必备软件：git、docker、docker-compose</p></li></ul><h4 id="开放端口" tabindex="-1"><a class="header-anchor" href="#开放端口" aria-hidden="true">#</a> 开放端口</h4><p>测试机开放需要的端口，让外网可以访问</p><ul><li>B 端 FE：<code>80</code></li><li>B 端 server：<code>8081</code></li><li>C 端：<code>8082</code></li><li>统计服务，收集日志：<code>8083</code></li><li>统计服务 OpenAPI：<code>8080</code></li><li>admin FE：<code>8085</code></li><li>admin server: <code>8084</code></li></ul><p><strong>线上环境不需要开发这么多端口，只需要使用 nginx 反向代理</strong></p><h4 id="梳理思路" tabindex="-1"><a class="header-anchor" href="#梳理思路" aria-hidden="true">#</a> 梳理思路</h4><ul><li><p>使用 github actions 监听 dev 分支 push</p></li><li><p>登录测试机，获取最新 dev 分支代码</p></li><li><p>重新构建镜像 <code>docker-compose build editor-server</code></p></li><li><p>重启所有容器 <code>docker-compose up -d</code></p></li></ul><h2 id="第-16-周-编辑器服务端基础-api-开发" tabindex="-1"><a class="header-anchor" href="#第-16-周-编辑器服务端基础-api-开发" aria-hidden="true">#</a> 第 16 周 编辑器服务端基础 API 开发</h2><ul><li>技术方案设计和基础功能开发</li></ul><h3 id="技术方案设计和基础功能开发" tabindex="-1"><a class="header-anchor" href="#技术方案设计和基础功能开发" aria-hidden="true">#</a> 技术方案设计和基础功能开发</h3><p>需求指导设计，设计指导开发，无设计不开发。</p><ul><li>1.服务端技术方案设计的方法</li><li>2.B 端和编辑器基本功能 API</li></ul><h3 id="_1-服务端技术方案设计的方法" tabindex="-1"><a class="header-anchor" href="#_1-服务端技术方案设计的方法" aria-hidden="true">#</a> 1.服务端技术方案设计的方法</h3><ul><li>1.1 接口设计</li><li>1.2 数据库设计</li><li>1.3 选择 Restful API 而非 GraphQL</li></ul><h3 id="_1-1-接口设计" tabindex="-1"><a class="header-anchor" href="#_1-1-接口设计" aria-hidden="true">#</a> 1.1 接口设计</h3><p>在需求评审的时候，需要思考要用到哪些接口，接口有哪些输入和输出，接口是否合理，接口是否能够实现。</p><p>需要具体的设计出每个接口的输入与输出。</p><p>可以使用工具做设计，比如 postman</p><h4 id="b-端功能拆分" tabindex="-1"><a class="header-anchor" href="#b-端功能拆分" aria-hidden="true">#</a> B 端功能拆分</h4><ul><li>用户信息</li><li>模板管理</li><li>我的作品管理</li><li>编辑器</li><li>渠道</li><li>工具类</li></ul><p><strong>用户信息</strong></p><ul><li>获取手机短信验证码（思考输入什么，输出什么）</li><li>登录（包含注册）</li><li>获取用户信息</li><li>修改用户信息</li></ul><p><strong>模板管理：</strong></p><ul><li>首页推荐模板列表，分页，搜索</li><li>获取单个模板信息</li><li>我的模板列表，分页，搜索</li></ul><p><strong>作品管理：</strong></p><ul><li>创建空白作品</li><li>复制作品</li><li>删除作品</li><li>恢复作品</li><li>转赠作品</li><li>我的作品列表，分页，搜索</li><li>我的回收站列表，分页，搜索</li></ul><p><strong>编辑器：</strong></p><ul><li>查询单个作品信息</li><li>保存作品</li><li>预览作品</li><li>发布为作品</li><li>发布为模板</li></ul><p><strong>渠道：</strong></p><ul><li><p>创建渠道</p></li><li><p>删除渠道</p></li><li><p>修改渠道名称</p></li><li><p>获取单个作品的所有渠道</p></li><li><p><strong>工具类：</strong></p></li><li><p>上传图片</p></li></ul><h4 id="统一的输出格式" tabindex="-1"><a class="header-anchor" href="#统一的输出格式" aria-hidden="true">#</a> 统一的输出格式</h4><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;errno&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;data&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;message&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_1-2-数据库设计" tabindex="-1"><a class="header-anchor" href="#_1-2-数据库设计" aria-hidden="true">#</a> 1.2 数据库设计</h3><p><strong>需要存储的数据：</strong></p><ul><li>用户</li><li>作品/模板</li><li>渠道</li></ul><p><strong>数据之间的关系：</strong></p><p>一个用户可以创建很多个作品（1 对多关系），一个作品可以创建很多个渠道（1 对多关系），一个作品只对应一个内容（1 对 1 关系）。</p><p><img src="http://www.lcong.cn/assets/images/knowledge/computers/architect/B端/数据之间的关系.jpg" alt="image"></p><h4 id="数据表设计" tabindex="-1"><a class="header-anchor" href="#数据表设计" aria-hidden="true">#</a> 数据表设计</h4><p><strong>用户：</strong></p><table><thead><tr><th>列</th><th>类型</th><th>注释</th></tr></thead><tbody><tr><td>username</td><td>varchar</td><td>用户名</td></tr><tr><td>password</td><td>varchar</td><td>密码（保留字段，暂时用不到）</td></tr><tr><td>phoneNumber</td><td>varchar</td><td>手机号</td></tr><tr><td>nickName</td><td>varchar</td><td>昵称</td></tr><tr><td>gender</td><td>int</td><td>性别</td></tr><tr><td>picture</td><td>varchar</td><td>用户头像</td></tr></tbody></table><p><strong>作品/模板：</strong></p><p>同上，省略...</p><table><thead><tr><th>列</th><th>类型</th><th>注释</th></tr></thead><tbody><tr><td>uuid</td><td>varchar</td><td>h5 url 中使用，隐藏真正的 id，避免被爬</td></tr><tr><td>contentId</td><td>varchar</td><td>未发布内容 id，内容存储在 MongoDB 中</td></tr><tr><td>publishContentId</td><td>varchar</td><td>布内容 id，内容存储在 MongoDB 中，未发布的为空</td></tr><tr><td>isTemplate</td><td>boolean</td><td>是否模板</td></tr><tr><td>status</td><td>int</td><td>状态：0=删除，1=未发布，2=发布，3=强制线下</td></tr></tbody></table><p><strong>渠道：</strong></p><p>同上，省略...</p><h4 id="作品内容" tabindex="-1"><a class="header-anchor" href="#作品内容" aria-hidden="true">#</a> 作品内容</h4><ul><li>未发布</li><li>已发布</li></ul><p>MongoDB</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token comment">// 页面的组件列表</span>\n  components<span class="token operator">:</span> <span class="token punctuation">[</span>Object<span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token comment">// 页面的属性</span>\n  props<span class="token operator">:</span> Object<span class="token punctuation">,</span>\n  <span class="token comment">// 配置信息</span>\n  setting<span class="token operator">:</span> Object<span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="sequelize-model-以及关联关系" tabindex="-1"><a class="header-anchor" href="#sequelize-model-以及关联关系" aria-hidden="true">#</a> sequelize Model 以及关联关系</h4><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 和 UserModel 建立关系</span>\nWork<span class="token punctuation">.</span><span class="token function">belongsTo</span><span class="token punctuation">(</span>UserModel<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  foreignKey<span class="token operator">:</span> <span class="token string">&#39;author&#39;</span><span class="token punctuation">,</span>\n  targetKey<span class="token operator">:</span> <span class="token string">&#39;username&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 对应 UserModel.username 属性</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="mongoose-schema-和-model" tabindex="-1"><a class="header-anchor" href="#mongoose-schema-和-model" aria-hidden="true">#</a> mongoose Schema 和 Model</h4><ul><li>未发布的内容：workContent</li><li>已发布的内容：workPublishContent</li></ul><h3 id="b-端-server-整体架构图" tabindex="-1"><a class="header-anchor" href="#b-端-server-整体架构图" aria-hidden="true">#</a> B 端-server 整体架构图</h3><p>完成上面步骤之后，再设计出整体架构图，结合接口设计，数据库设计，数据格式设计，将各个功能和模块抽象成一张图来表示。</p><p>结构是一层又一层，每一个模块使用不同颜色标记，越底层越抽象，底层的支撑上层的，最上层的是对外开放的路由。</p><p><img src="http://www.lcong.cn/assets/images/knowledge/computers/architect/B端/server-整体架构图.jpg" alt="image"></p><h3 id="biz-editor-server-端技术方案" tabindex="-1"><a class="header-anchor" href="#biz-editor-server-端技术方案" aria-hidden="true">#</a> biz-editor-server 端技术方案</h3><p>评审技术方案设计前，最后整理出一份技术方案文档，让人能够对这个系统有一个初步的整体认识。</p><p><strong>范围：</strong></p><ul><li>B 端 + 编辑器 server</li><li>多项目关系图，当前的范围，与其它模块的关系</li></ul><p><strong>技术选型：</strong></p><ul><li>框架</li><li>数据库</li><li>登录校验</li><li>单元测试</li><li>发布上线</li><li>CI/CD</li></ul><p><strong>整体架构设计：</strong></p><ul><li>整体架构图</li></ul><p><strong>接口设计：</strong></p><ul><li>范围、各个接口列表</li><li>接口输入和输入（只评审关键的、有疑问的接口）</li></ul><p><strong>数据库设计：</strong></p><ul><li>数据关系</li><li>数据表</li></ul><h3 id="基本功能开发" tabindex="-1"><a class="header-anchor" href="#基本功能开发" aria-hidden="true">#</a> 基本功能开发</h3><ul><li>登录功能</li><li>用户信息接口</li><li>作品接口</li><li>模板接口</li></ul><h4 id="登录功能" tabindex="-1"><a class="header-anchor" href="#登录功能" aria-hidden="true">#</a> 登录功能</h4><p>短信功能，初次发短信，再次发短信。</p><p>考虑费用，禁止频繁发送，短信服务的报警，稳定性。</p><p>使用短信验证码直接登录，比用户名和密码登录更加简单方便，用户名和密码登录还需要配套功能，比如忘记密码、修改密码，这些功能做起来也很费力，而且也要发短信。</p>',143),n={render:function(e,i){return a}}}}]);