"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[6475],{1048:(e,i,a)=>{a.r(i),a.d(i,{data:()=>l});const l={key:"v-bc6f5c9a",path:"/web-developer/back-end/java/oop.html",title:"面向对象编程",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"基本概念",slug:"基本概念",children:[]},{level:3,title:"使用",slug:"使用",children:[]},{level:3,title:"修饰符",slug:"修饰符",children:[]},{level:3,title:"this 变量",slug:"this-变量",children:[]},{level:3,title:"继承",slug:"继承",children:[]},{level:3,title:"多态",slug:"多态",children:[]},{level:3,title:"抽象类",slug:"抽象类",children:[]},{level:3,title:"接口",slug:"接口",children:[]},{level:3,title:"静态字段和静态方法",slug:"静态字段和静态方法",children:[]},{level:2,title:"核心类",slug:"核心类",children:[{level:3,title:"String",slug:"string",children:[]}]}],filePathRelative:"web-developer/back-end/java/oop.md",git:{updatedTime:1690944334e3,contributors:[{name:"licong96",email:"licong19961204@gmail.com",commits:1}]}}},2189:(e,i,a)=>{a.r(i),a.d(i,{default:()=>t});const l=(0,a(6252).uE)('<h1 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程" aria-hidden="true">#</a> 面向对象编程</h1><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><p>在 OOP 中，class 和 instance 是“模版”和“实例”的关系；</p><p>定义 class 就是定义了一种数据类型，对应的 instance 是这种数据类型的实例；</p><p>通过 new 操作符创建新的 instance，然后用变量指向它，即可通过变量来引用这个 instance；</p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>类属性设置为 private，不允许外部直接修改，需要通过调用实例方法修改和读取。</p><p>类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p><p>方法可以让外部代码安全地访问实例中的字段。</p><h3 id="修饰符" tabindex="-1"><a class="header-anchor" href="#修饰符" aria-hidden="true">#</a> 修饰符</h3><ul><li>public：定义了类对外提供的功能</li><li>private：访问权限被限定在 class 的内部，外部无法调用</li><li>protected：子类，以及子类的子类可以访问</li></ul><h3 id="this-变量" tabindex="-1"><a class="header-anchor" href="#this-变量" aria-hidden="true">#</a> this 变量</h3><p>在方法内部，可以使用一个隐含的变量 this，它始终指向当前实例。</p><p>如果没有命名冲突，可以省略 this。</p><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h3><p>继承是面向对象编程的一种强大的代码复用方式。</p><p>子类的构造方法可以通过 super()调用父类的构造方法；</p><p>继承有个特点，就是子类无法访问父类的 private 字段或者 private 方法。</p><p>为了让子类可以访问父类的字段，我们需要把 private 改为 protected。用 protected 修饰的字段可以被子类访问。</p><h3 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h3><ul><li><p>Override：复写</p></li><li><p>Overload：方法重载</p></li><li><p>final</p><ul><li>修饰的方法可以阻止被覆写</li><li>修饰的 class 可以阻止被继承</li><li>修饰的 field 必须在创建对象时初始化，随后不可修改</li></ul></li></ul><p>子类可以覆写父类的方法</p><p>多态的特性就是，运行期才能动态决定调用的子类方法。</p><h3 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h3><ul><li>abstract</li></ul><p>通过 abstract 定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p><p>定义了抽象方法的 class 必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</p><p>抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p><strong>面向抽象编程：</strong></p><p>尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>上层代码只定义规范，不需要子类就可以实现业务逻辑，具体的业务逻辑由不同的子类实现，调用者并不关心。</p><p>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</p><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h3><ul><li>interface</li><li>implements</li><li>default：实现类可以不必覆写 default 方法</li></ul><p>接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</p><p>接口的所有方法都是抽象方法，接口不能定义实例字段；</p><h3 id="静态字段和静态方法" tabindex="-1"><a class="header-anchor" href="#静态字段和静态方法" aria-hidden="true">#</a> 静态字段和静态方法</h3><ul><li>static</li></ul><p>静态字段属于所有实例“共享”的字段，实际上是属于 class 的字段；</p><p>推荐用类名来访问静态字段和方法。</p><p>实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。</p><p>调用静态方法不需要实例，无法访问 this，但可以访问静态字段和其他静态方法；</p><p>静态方法常用于工具类和辅助方法。</p><h2 id="核心类" tabindex="-1"><a class="header-anchor" href="#核心类" aria-hidden="true">#</a> 核心类</h2><ul><li>String</li><li>StringBuilder</li><li>StringJoiner</li><li>包装类型</li><li>JavaBean</li><li>枚举</li></ul><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><p>在 Java 中，String 是一个引用类型，它本身也是一个 class。但是，Java 编译器对 String 有特殊处理，即可以直接用&quot;...&quot;来表示一个字符串。</p><p>Java 字符串 String 是不可变对象；</p><p>字符串操作不改变原字符串内容，而是返回新字符串；</p><p>两个字符串比较，必须总是使用 equals()方法。</p>',50),t={render:function(e,i){return l}}}}]);