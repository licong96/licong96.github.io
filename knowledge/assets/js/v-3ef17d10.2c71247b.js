"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[3102],{9187:(e,l,i)=>{i.r(l),i.d(l,{data:()=>r});const r={key:"v-3ef17d10",path:"/web-developer/front-end/javascript/async.html",title:"异步",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"单线程",slug:"单线程",children:[{level:3,title:"避免 DOM 渲染阻塞和冲突",slug:"避免-dom-渲染阻塞和冲突",children:[]}]},{level:2,title:"Event Loop",slug:"event-loop",children:[{level:3,title:"DOM 渲染",slug:"dom-渲染",children:[]}]}],filePathRelative:"web-developer/front-end/javascript/async.md",git:{updatedTime:1677050963e3,contributors:[{name:"licong96",email:"licong19961204@gmail.com",commits:1}]}}},9861:(e,l,i)=>{i.r(l),i.d(l,{default:()=>d});var r=i(6252);const a=(0,r.uE)('<h1 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h1><ol><li>单线程</li><li>Event Loop</li><li>jQuery 的 Deferred</li><li>Promise</li><li>Async/Await</li></ol><h2 id="单线程" tabindex="-1"><a class="header-anchor" href="#单线程" aria-hidden="true">#</a> 单线程</h2><p>JavaScript 之所以使用单线程，是因为它最初是为了处理网页上的交互和动态效果而设计的。而且使用单线程可以避免 DOM 渲染阻塞和冲突。</p><p>浏览器中 JS 执行和 DOM 渲染共用一个线程。</p><p><strong>单线程的特点是：</strong></p><ol><li>顺序执行：一次只能执行一个任务。</li><li>阻塞式：当执行一个任务时，如果该任务需要等待某些操作完成，那么该任务会被阻塞，直到操作完成后才能继续执行。</li><li>非阻塞式：为了避免阻塞，单线程通常采用异步机制。</li><li>使用回调函数处理异步任务结果</li><li>可靠性高：由于单线程只有一个执行上下文，因此不需要考虑线程同步、锁等多线程编程问题</li></ol><h3 id="避免-dom-渲染阻塞和冲突" tabindex="-1"><a class="header-anchor" href="#避免-dom-渲染阻塞和冲突" aria-hidden="true">#</a> 避免 DOM 渲染阻塞和冲突</h3><ul><li>浏览器需要渲染 DOM</li><li>JS 可以修改 DOM 结构</li><li>JS 执行的时候，浏览器 DOM 渲染会暂停</li><li>如果是多线程 JS 同时执行，可能导致 DOM 冲突</li><li>webworker 支持多线程，但是不能访问 DOM</li></ul><p><strong>JS 必须是单线程，和 DOM 渲染互斥，而且 JS 的执行必须这样设计才可靠。</strong></p><p><strong>然后使用异步来解决单线程阻塞问题。</strong></p><h2 id="event-loop" tabindex="-1"><a class="header-anchor" href="#event-loop" aria-hidden="true">#</a> Event Loop</h2><p>循环执行的顺序：</p><ol><li>在执行栈中执行一个宏观任务。</li><li>遇到同步代码直接执行，遇到异步代码，区分宏任务和微任务，添加到对应的任务队列中。</li><li>当前宏任务执行完毕后，立即执行下面的所有微任务。（微任务中优先级高的先执行）</li><li>微任务全部执行完毕后，GUI 接管 DOM 渲染。</li><li>继续从任务队列中查找下一个宏任务。</li></ol><p>微任务在下一轮 DOM 渲染之前执行，宏任务在 DOM 渲染之后执行。</p>',15),t={href:"https://github.com/licong96/blogs/issues/8",target:"_blank",rel:"noopener noreferrer"},n=(0,r.Uk)("参考文档"),o=(0,r.Wm)("h3",{id:"dom-渲染",tabindex:"-1"},[(0,r.Wm)("a",{class:"header-anchor",href:"#dom-渲染","aria-hidden":"true"},"#"),(0,r.Uk)(" DOM 渲染")],-1),d={render:function(e,l){const i=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.j4)(r.HY,null,[a,(0,r.Wm)("ul",null,[(0,r.Wm)("li",null,[(0,r.Wm)("a",t,[n,(0,r.Wm)(i)])])]),o],64)}}}}]);