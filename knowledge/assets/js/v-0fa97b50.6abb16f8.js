"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[2158],{1588:(e,a,r)=>{r.r(a),r.d(a,{data:()=>d});const d={key:"v-0fa97b50",path:"/web-developer/front-end/frame/SSR.html",title:"SSR",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"什么是服务器端渲染(SSR)？",slug:"什么是服务器端渲染-ssr",children:[]},{level:3,title:"什么是客户端渲染(CSR)？",slug:"什么是客户端渲染-csr",children:[]},{level:3,title:"SSR比CSR好在哪里？",slug:"ssr比csr好在哪里",children:[]},{level:2,title:"SSR和CSR的渲染流程",slug:"ssr和csr的渲染流程",children:[]},{level:2,title:"性能对比",slug:"性能对比",children:[]},{level:2,title:"node.js下使用common.js语法",slug:"node-js下使用common-js语法",children:[]},{level:2,title:"在服务器端配置webpack",slug:"在服务器端配置webpack",children:[{level:3,title:"实现服务器端组件渲染",slug:"实现服务器端组件渲染",children:[]}]},{level:2,title:"什么是同构？",slug:"什么是同构",children:[{level:3,title:"访问静态资源的中间件",slug:"访问静态资源的中间件",children:[]},{level:3,title:"客户端执行",slug:"客户端执行",children:[]},{level:3,title:"同构流程",slug:"同构流程",children:[]}]},{level:2,title:"路由",slug:"路由",children:[{level:3,title:"服务器端渲染只发生一次",slug:"服务器端渲染只发生一次",children:[]},{level:3,title:"中间层是什么？",slug:"中间层是什么",children:[]}]},{level:2,title:"loadData方法及路由重构",slug:"loaddata方法及路由重构",children:[]},{level:2,title:"数据的注水和脱水",slug:"数据的注水和脱水",children:[]},{level:2,title:"node服务器作为数据请求的中间层",slug:"node服务器作为数据请求的中间层",children:[]}],filePathRelative:"web-developer/front-end/frame/SSR.md",git:{updatedTime:1650512276e3,contributors:[{name:"黎聪",email:"licong23@xdf.cn",commits:2}]}}},9538:(e,a,r)=>{r.r(a),r.d(a,{default:()=>l});const d=(0,r(6252).uE)('<h1 id="ssr" tabindex="-1"><a class="header-anchor" href="#ssr" aria-hidden="true">#</a> SSR</h1><p>类似于传统后端渲染技术的回归，这个技术非常适合用来做网站，适合大型网站，方便SEO。</p><h3 id="什么是服务器端渲染-ssr" tabindex="-1"><a class="header-anchor" href="#什么是服务器端渲染-ssr" aria-hidden="true">#</a> 什么是服务器端渲染(SSR)？</h3><p>服务器端渲染指的是，页面上的内容在服务器上就已经生成好了，服务器把内容给到浏览器，浏览器直接将内容显示在页面上就可以了。</p><p>只有第一次进入第一个页面的时候，由服务器端渲染，后面的页面全部由客户端渲染。</p><h3 id="什么是客户端渲染-csr" tabindex="-1"><a class="header-anchor" href="#什么是客户端渲染-csr" aria-hidden="true">#</a> 什么是客户端渲染(CSR)？</h3><p>页面由JS渲染，JS运行在客户端，所以叫客户端渲染。</p><h3 id="ssr比csr好在哪里" tabindex="-1"><a class="header-anchor" href="#ssr比csr好在哪里" aria-hidden="true">#</a> SSR比CSR好在哪里？</h3><p>有两个最大的好处： 1.首屏加载速度。 2.SEO</p><p>用户加载页面的时候，对于SSR，浏览器下载HTML文档完毕就可以显示。对于CSR，浏览器下载HTML -&gt; 下载JS文件 -&gt; 运行React代码 -&gt; 渲染页面。</p><h2 id="ssr和csr的渲染流程" tabindex="-1"><a class="header-anchor" href="#ssr和csr的渲染流程" aria-hidden="true">#</a> SSR和CSR的渲染流程</h2><p>客户端渲染流程：浏览器发送请求 -&gt; 服务器返回HTML -&gt; 浏览器发送js请求 -&gt; 服务器返回js -&gt; 浏览器执行js中的React代码</p><p>服务器端渲染流程：浏览器发送请求 -&gt; 服务器运行React代码生成页面 -&gt; 服务器返回页面</p><h2 id="性能对比" tabindex="-1"><a class="header-anchor" href="#性能对比" aria-hidden="true">#</a> 性能对比</h2><p>服务器端渲染，React代码运行在服务器上，消耗服务器的性能。 客户端渲染，React代码运行在客户端上，消耗用户浏览器的性能。</p><h2 id="node-js下使用common-js语法" tabindex="-1"><a class="header-anchor" href="#node-js下使用common-js语法" aria-hidden="true">#</a> node.js下使用common.js语法</h2><p>require和module.exports</p><p>配置了webpack之后，就可以使用ES6模块方法。</p><h2 id="在服务器端配置webpack" tabindex="-1"><a class="header-anchor" href="#在服务器端配置webpack" aria-hidden="true">#</a> 在服务器端配置webpack</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>module.export = {\n    target: &#39;node&#39;  // 告诉webpack打包的是服务器端的文件\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>利用nodemon实现服务器自动重启更新页面</p><h3 id="实现服务器端组件渲染" tabindex="-1"><a class="header-anchor" href="#实现服务器端组件渲染" aria-hidden="true">#</a> 实现服务器端组件渲染</h3><p>需要使用<code>React-dom/server</code>下的<code>renderToString</code>方法。</p><p>建立在虚拟DOM上的服务器端渲染</p><h2 id="什么是同构" tabindex="-1"><a class="header-anchor" href="#什么是同构" aria-hidden="true">#</a> 什么是同构？</h2><p>一套React代码，在服务器端执行一次，到客户端再执行一次。 服务器端执行渲染页面，客户端执行可以解决点击事件无效的问题。</p><h3 id="访问静态资源的中间件" tabindex="-1"><a class="header-anchor" href="#访问静态资源的中间件" aria-hidden="true">#</a> 访问静态资源的中间件</h3><p>app.use(express.static(&#39;public&#39;));</p><h3 id="客户端执行" tabindex="-1"><a class="header-anchor" href="#客户端执行" aria-hidden="true">#</a> 客户端执行</h3><p>给客户端单独配置一份webpack</p><p>渲染需要使用<code>ReactDom.hydrate()</code>方法</p><h3 id="同构流程" tabindex="-1"><a class="header-anchor" href="#同构流程" aria-hidden="true">#</a> 同构流程</h3><ol><li>服务器端运行React代码渲染出HTML</li><li>发送HTML给浏览器</li><li>浏览器接受到内容展示</li><li>浏览器加载JS文件</li><li>JS中的React代码在浏览器中重新执行</li><li>JS中的React代码接管页面操作</li></ol><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由" aria-hidden="true">#</a> 路由</h2><p>需要在客户端和服务器端都运行一遍。服务器端需要使用<code>StaticRouter</code>。</p><h3 id="服务器端渲染只发生一次" tabindex="-1"><a class="header-anchor" href="#服务器端渲染只发生一次" aria-hidden="true">#</a> 服务器端渲染只发生一次</h3><p>首次访问之后，React将全部接管，后面切换路由，服务器端不会再渲染。</p><h3 id="中间层是什么" tabindex="-1"><a class="header-anchor" href="#中间层是什么" aria-hidden="true">#</a> 中间层是什么？</h3><p>属于项目架构的一部分。node服务器就是中间层，从Java服务器获取数据，拼接好页面发送给客户端。</p><p>这样做分工明确，对性能也有好处。</p><p>客户端 -&gt; node服务器 -&gt; java服务器。</p><h2 id="loaddata方法及路由重构" tabindex="-1"><a class="header-anchor" href="#loaddata方法及路由重构" aria-hidden="true">#</a> loadData方法及路由重构</h2><p>拿到异步数据，填充到store中。 react-router-dom官网提供了方法和实例。server-rendering。</p><h2 id="数据的注水和脱水" tabindex="-1"><a class="header-anchor" href="#数据的注水和脱水" aria-hidden="true">#</a> 数据的注水和脱水</h2><p>注水：服务器端将请求到的数据，添加到<code>window</code>全局对象下。 脱水：客户端渲染的时候，从<code>window</code>下取出数据，设置为store的默认数据。</p><h2 id="node服务器作为数据请求的中间层" tabindex="-1"><a class="header-anchor" href="#node服务器作为数据请求的中间层" aria-hidden="true">#</a> node服务器作为数据请求的中间层</h2><p>客户端请求数据：客户端向node服务器发送请求，node服务器再代理到java服务器。 node端请求数据：node端直接向java服务器发送请求。</p>',47),l={render:function(e,a){return d}}}}]);