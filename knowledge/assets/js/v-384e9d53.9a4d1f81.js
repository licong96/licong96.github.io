"use strict";(self.webpackChunkknowledge=self.webpackChunkknowledge||[]).push([[4024],{8583:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-384e9d53",path:"/web-developer/back-end/node/node-modules.html",title:"Node Modules 模块系统",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"模块化",slug:"模块化",children:[]},{level:2,title:"CommonJS",slug:"commonjs",children:[{level:3,title:"require",slug:"require",children:[]}]},{level:2,title:"ES Module",slug:"es-module",children:[{level:3,title:"Node 项目如何支持 ES Module",slug:"node-项目如何支持-es-module",children:[]},{level:3,title:"1.使用 webpack",slug:"_1-使用-webpack",children:[]},{level:3,title:"2.通过 Node 原生支持",slug:"_2-通过-node-原生支持",children:[]},{level:3,title:'3. 方案三：在文件的顶部添加 "type": "module" 的语句',slug:"_3-方案三-在文件的顶部添加-type-module-的语句",children:[]}]},{level:2,title:"全局包",slug:"全局包",children:[{level:3,title:"目录结构",slug:"目录结构",children:[]}]},{level:2,title:"模块的加载顺序",slug:"模块的加载顺序",children:[]},{level:2,title:"模块的循环依赖",slug:"模块的循环依赖",children:[]}],filePathRelative:"web-developer/back-end/node/node-modules.md",git:{updatedTime:1676882536e3,contributors:[{name:"licong96",email:"licong19961204@gmail.com",commits:2}]}}},9802:(e,n,s)=>{s.r(n),s.d(n,{default:()=>o});const a=(0,s(6252).uE)('<h1 id="node-modules-模块系统" tabindex="-1"><a class="header-anchor" href="#node-modules-模块系统" aria-hidden="true">#</a> Node Modules 模块系统</h1><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h2><p>有过的解决方案：</p><ul><li>CMD/AMD/require.js</li><li>CommonJS</li><li>ES Module</li></ul><p>nodejs 默认支持<code>CommonJS</code>模块化，从版本 12.0.0 开始支持 ES Modules (ESM)。</p><h2 id="commonjs" tabindex="-1"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h2><p><strong>导入</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> variable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;*&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>导出</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="require" tabindex="-1"><a class="header-anchor" href="#require" aria-hidden="true">#</a> require</h3><p><strong>require 支持加载的类型：</strong></p><ol><li><code>.js</code></li><li><code>.json</code></li><li><code>.node</code></li><li>任何类型的文件，都会视为<code>.js</code>去解析</li></ol><p><strong>针对不同的文件类型，有不同的处理方式：</strong></p><ol><li><p>如果是<code>.js</code>文件，里面需要使用<code>module.exports</code>或<code>exports</code>输出一个模块。</p></li><li><p>如果是<code>.json</code>文件，会使用<code>JSON.parse</code>解析为 json 对象</p></li><li><p>如果是<code>.node</code>文件，会使用<code>process.dlopen</code>打开一个 C++插件</p></li></ol><h2 id="es-module" tabindex="-1"><a class="header-anchor" href="#es-module" aria-hidden="true">#</a> ES Module</h2><ul><li><p>导入：<code>import</code></p></li><li><p>导出：<code>export</code></p></li></ul><h3 id="node-项目如何支持-es-module" tabindex="-1"><a class="header-anchor" href="#node-项目如何支持-es-module" aria-hidden="true">#</a> Node 项目如何支持 ES Module</h3><p>解决方案：</p><ol><li><p>使用 webpack</p></li><li><p>通过 Node 原生支持（版本号大于 12.0.0）</p></li></ol><h3 id="_1-使用-webpack" tabindex="-1"><a class="header-anchor" href="#_1-使用-webpack" aria-hidden="true">#</a> 1.使用 webpack</h3><p>将<code>ES Module</code>的语法转换成<code>CommonJS</code>，打包成普通的 js 文件。</p><p>为了兼容低版本 node，需要使用<code>bable</code>，如果使用了<code>async/await</code>还需要添加<code>@babel/plugin-transform-runtime</code></p><p>配置<code>webpack.config.js</code>文件：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{\n  target: &#39;node&#39;, // 默认是web，需要改为node，去加载node内置库\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-通过-node-原生支持" tabindex="-1"><a class="header-anchor" href="#_2-通过-node-原生支持" aria-hidden="true">#</a> 2.通过 Node 原生支持</h3><ol><li>方案一：将<code>.js</code>文件后缀名改为<code>.mjs</code></li><li>方案二：修改<code>package.json</code>文件</li><li>方案三：在文件的顶部添加 &quot;type&quot;: &quot;module&quot; 的语句</li></ol><h4 id="_1-方案一-修改后缀名为-mjs" tabindex="-1"><a class="header-anchor" href="#_1-方案一-修改后缀名为-mjs" aria-hidden="true">#</a> 1. 方案一：修改后缀名为<code>.mjs</code></h4><p>1.1 更改 js 文件后缀名为<code>.mjs</code></p><p>1.2 import 的时候，不能省略后缀名</p><p>1.3 执行<code>.mjs</code>文件</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># node版本`&gt;= v14`，可以直接执行</span>\nnode ./bin/index.mjs\n\n<span class="token comment"># or</span>\n\n<span class="token comment"># node版本低于`v14`，需要配置开启：`--experimental-modules`</span>\nnode --experimental-modules ./bin/index.mjs\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_2-方案二-修改package-json文件" tabindex="-1"><a class="header-anchor" href="#_2-方案二-修改package-json文件" aria-hidden="true">#</a> 2. 方案二：修改<code>package.json</code>文件</h4><p>2.1 修改<code>package.json</code>：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{\n  &quot;type&quot;: &quot;module&quot;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>默认将 js 文件全部转换为<code>ES Module</code>模式，但是如果使用<code>CommonJs</code>规范就需要把文件改为<code>*.cjs</code></p><p>2.2 执行：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>node ./bin/index.mjs\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">需要注意的几个点：</p><ol><li><p>ES Module 中可以导入 CommonJs 模块</p></li><li><p>CommonJs 中不能导入 ES Module 模块</p></li><li><p>CommonJs 始终只会导出一个默认成员</p></li><li><p>注意 import 不能解构导出的对象</p></li></ol></div><h3 id="_3-方案三-在文件的顶部添加-type-module-的语句" tabindex="-1"><a class="header-anchor" href="#_3-方案三-在文件的顶部添加-type-module-的语句" aria-hidden="true">#</a> 3. 方案三：在文件的顶部添加 &quot;type&quot;: &quot;module&quot; 的语句</h3><p>在 Node.js 中，使用 ES Modules 需要在文件的顶部添加 &quot;type&quot;: &quot;module&quot; 的语句，表示该文件采用 ES Modules 格式。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// index.mjs</span>\n\n<span class="token keyword">import</span> <span class="token punctuation">{</span> greet <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./module.js&#39;</span><span class="token punctuation">;</span>\n\n<span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">&#39;world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// module.js</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="在-node-js-中-使用-es-modules-还需要注意以下事项" tabindex="-1"><a class="header-anchor" href="#在-node-js-中-使用-es-modules-还需要注意以下事项" aria-hidden="true">#</a> 在 Node.js 中，使用 ES Modules 还需要注意以下事项：</h4><ol><li><p>在 ESM 中，没有全局的 require() 函数和 module.exports 对象，所以需要使用 import 和 export 语法来加载和导出模块。</p></li><li><p>在 ESM 中，不能使用动态导入语法，例如 import(&#39;module.js&#39;)，只能使用静态导入语法，例如 import { x } from &#39;module.js&#39;。</p></li><li><p>在 ESM 中，模块的路径必须是相对路径或绝对路径，不能使用模块标识符，例如 import fs from &#39;fs&#39;。</p></li></ol><h2 id="全局包" tabindex="-1"><a class="header-anchor" href="#全局包" aria-hidden="true">#</a> 全局包</h2><ol><li><p>使用<code>which node</code>查看全局软链接路径: <code>/Users/cass/.nvm/versions/node/v16.16.0/bin/node</code></p></li><li><p>进入 bin 文件夹，使用<code>ls -la</code>可以查看到所有命令具体执行的文件</p></li></ol><h3 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h3><ul><li><p><code>bin</code>目录存放的是全局命令</p></li><li><p><code>lib -&gt; node_modules</code>目录存放的是全局包源码</p></li></ul><h2 id="模块的加载顺序" tabindex="-1"><a class="header-anchor" href="#模块的加载顺序" aria-hidden="true">#</a> 模块的加载顺序</h2><p>Node.js 模块的加载顺序是按照以下顺序来加载的：</p><ol><li><p>首先，Node.js 会查找该模块是否已经被缓存，如果已经被缓存，则直接从缓存中加载。</p></li><li><p>如果没有被缓存，则按照模块的文件名来查找模块，如果文件名包含路径，则按照路径查找；否则，按照 Node.js 模块加载规则查找。</p></li><li><p>Node.js 模块加载规则是按照以下顺序查找模块：</p><p>3.1 先查找该模块是否是 Node.js 内置模块，如果是，则直接加载。</p><p>3.2 如果不是内置模块，则按照 NODE_PATH 环境变量和当前模块的 node_modules 目录查找该模块。</p><p>3.3 如果还没有找到该模块，则递归查找该模块的依赖模块。</p></li></ol><h2 id="模块的循环依赖" tabindex="-1"><a class="header-anchor" href="#模块的循环依赖" aria-hidden="true">#</a> 模块的循环依赖</h2><p>循环依赖是指两个或多个模块之间相互依赖的情况。在 Node.js 中，循环依赖会导致模块加载失败，因此需要谨慎处理循环依赖问题。可以通过延迟加载、重构代码和使用依赖注入等方式来解决循环依赖问题。</p>',54),o={render:function(e,n){return a}}}}]);